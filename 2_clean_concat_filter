# -*- coding: utf-8 -*-
"""
Created on Thu Dec  4 14:44:16 2025

@author: navar
"""

# -*- coding: utf-8 -*-
"""
EEG – Paso 2 CORREGIDO (2B + 2C)

Objetivo:
  ✔ Conservar TODOS los canales (EEG + ECG + EMG + misc)
  ✔ Detectar canales EEG malos (manual PSD + auto RMS)
  ✔ Interpolar SOLO esos EEG malos
  ✔ Filtrar 0.5–45 Hz SIN borrar canales no EEG
  ✔ Guardar eeg_allblocks_05_45.fif con TODOS los canales originales
"""

from pathlib import Path
import numpy as np
import mne
import pandas as pd

BASE = Path(r"C:\Users\navar\Desktop\ds004388-1.0.0")
IN_DIR  = BASE / "eeg_step1_antialias"
OUT_DIR = BASE / "eeg_step2_clean_concat_05_45"
OUT_DIR.mkdir(exist_ok=True, parents=True)

BAD_PSD_CSV = BASE / "bad_eeg_channels_from_psd_clicks.csv"
BAD_FINAL_CSV = BASE / "bad_eeg_channels_final.csv"

# === Tus 64 EEG reales ===
EEG_CHANNELS = [
    "Fp1","Fp2","Fp2","F3","F4","C3","C4","P3","P4","O1","O2",
    "F7","F8","T7","T8","P7","P8","AFz","Fz","Cz","Pz",
    "FC1","FC2","CP1","CP2","FC5","FC6","CP5","CP6",
    "FT9","FT10","FCz","F1","F2","C1","C2","P1","P2",
    "AF3","AF4","FC3","FC4","CP3","CP4","PO3","PO4",
    "F5","F6","C5","C6","P5","P6","AF7","AF8","FT7","FT8",
    "TP7","TP8","PO7","PO8","FPz","CPz","F9","F10"
]


# === Cargar malos manuales del PSD ===
def load_bad_from_psd():
    if not BAD_PSD_CSV.exists():
        print("⚠ No PSD CSV → sin malos manuales.")
        return {}

    df = pd.read_csv(BAD_PSD_CSV)

    bad_dict = {}
    for _, r in df.iterrows():
        subj = r["subject"]
        if isinstance(r["bad_channels"], str) and r["bad_channels"].strip():
            chans = [c.strip() for c in r["bad_channels"].split(";")]
        else:
            chans = []

        bad_dict.setdefault(subj, set()).update(chans)

    return {k: sorted(list(v)) for k, v in bad_dict.items()}


# === Detección RMS automática (solo EEG, pero sin borrar nada) ===
def detect_bad_by_rms(raw, factor=5.0):
    picks = mne.pick_channels(raw.ch_names, include=EEG_CHANNELS)
    if len(picks) == 0:
        return []

    data = raw.get_data(picks=picks)
    rms = np.sqrt(np.mean(data ** 2, axis=1))
    median = np.median(rms)
    bad_idx = np.where(rms > factor * median)[0]

    return [raw.ch_names[picks[i]] for i in bad_idx]


# === Pipeline 2B + 2C ===
def step2_clean_and_concat(subjects=range(1, 10)):

    bad_psd_dict = load_bad_from_psd()
    final_bad_rows = []

    for s in subjects:
        subj = f"sub-{s:03d}"
        subj_dir = IN_DIR / subj
        fif_files = sorted(subj_dir.glob("*_aa.fif"))

        if not fif_files:
            print(f"{subj}: No AA files, skipping.")
            continue

        print(f"\n===== {subj} =====")

        raws = []
        auto_bad_all = []

        # === Cargar cada bloque SIN eliminar canales ===
        for fif in fif_files:
            print(f"  Loading {fif.name}")
            raw_block = mne.io.read_raw_fif(fif, preload=True, verbose="warning")

            # RMS solo en EEG – pero NO hacemos pick()
            eeg_ch = [ch for ch in EEG_CHANNELS if ch in raw_block.ch_names]
            picks_eeg = mne.pick_channels(raw_block.ch_names, eeg_ch)

            if len(picks_eeg) > 0:
                bad_rms = detect_bad_by_rms(raw_block)
                if bad_rms:
                    print(f"   → Auto RMS bad in {fif.name}: {bad_rms}")
                auto_bad_all.extend(bad_rms)

            raws.append(raw_block)

        # === Concatenar TODOS los canales ===
        print("  → Concatenating blocks...")
        raw = mne.concatenate_raws(raws)

        # === Combinar manual + auto ===
        manual_bad = bad_psd_dict.get(subj, [])
        auto_bad = list(set(auto_bad_all))
        combined_bad = sorted(list(set(manual_bad + auto_bad)))

        # Garantizar que existen
        combined_bad = [c for c in combined_bad if c in raw.ch_names]

        if combined_bad:
            print(f"  → Final bad EEG for {subj}: {combined_bad}")
            raw.info["bads"] = combined_bad
        else:
            print("  → No EEG bads for this subject.")

        # === Interpolación SOLO si hay suficientes EEG buenos ===
        if combined_bad:
            all_eeg = [ch for ch in EEG_CHANNELS if ch in raw.ch_names]
            good = [ch for ch in all_eeg if ch not in combined_bad]

            if len(good) < 4:
                print("  ⚠ Too few EEG good channels → skip interpolation.")
            else:
                print("  → Interpolating EEG bad channels...")
                raw.interpolate_bads()

        # === Filtrado global (TODOS los canales) ===
        print("  → Filtering 0.5–45 Hz...")
        raw.filter(
            l_freq=0.5,
            h_freq=45,
            method="iir",
            iir_params=dict(order=4, ftype="butter"),
            phase="zero",
            picks="all",
            verbose="error",
        )

        # === Guardar ===
        out_sub = OUT_DIR / subj
        out_sub.mkdir(exist_ok=True)
        out_path = out_sub / "eeg_allblocks_05_45.fif"
        raw.save(out_path, overwrite=True)
        print("  ✔ Saved:", out_path)

        # === Registrar malos finales ===
        final_bad_rows.append({
            "subject": subj,
            "bad_channels": ";".join(combined_bad)
        })

    # CSV final
    if final_bad_rows:
        pd.DataFrame(final_bad_rows).to_csv(BAD_FINAL_CSV, index=False)
        print(f"\n✔ Final bad channels CSV saved → {BAD_FINAL_CSV}")


# Ejecutar
if __name__ == "__main__":
    step2_clean_and_concat()


